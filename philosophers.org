#+title:     Philosophers
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* Early notes
** Task set up
Philosophers are threads?
Any number of philosophers in one (only) of 3 states.
Same number of forks (resource).
Philosophers need 2 forks to eat.
No communication between philosophers (threads?)
The time in the three states is taken as an argument.
Philosophers are numbered and also have a sitting position (not sure why that matters, maybe because the forks stay in the same place).
How would you model the forks? They don't do anything, really. They have a position and are either in use or not in use. If in use, do we record (there) with philosopher is using the fork? Just that it is in use (reserved, has a mutex on it?)
MutEx = Mutual Exclusion.
Have to keep logs: Timestamps, philosopher numbers and one of five actions.
Seems like if there is only one philosopher there is only one fork, and she will die.
The location of the forks, does that matter or am I taking the metaphor too far? The forks don't *move*, so for example, 2 philos could eat alternately. Eat, release your forks. The other picks up and eats
There must be some key time after you have picked up a fork: time eating + plus time sleeping + time to die amounts to the time that can be spent thinking before it wants to eat (?). -- what are the warning states or times here?
*** Functions in play
*No* libft.
Lots of pthread things
"protect the forks with a mutex"??
Time-related functions (gettimeofday)
**** gettimeofday
#+begin_src c
#include <sys/time.h>
struct timeval {
	time_t 		tv_sec;
	suseconds_t	tv_usec
};
    int gettimeofday(struct timeval *tv, struct timezone *tz)
#+end_src
the timeval struct gives the number of seconds and microseconds since the Epoch (i.e. it just keeps going up after the start)
The timezone "is obsolete" and should normally be specified as NULL
To get milliseconds from  the timeval, I need a function. What should it return? (seconds * 1000) + (suseconds / 1000) ?
**** usleep
#+begin_src c
#include <unistd.h>
int usleep(useconds_t n);
#+end_src
Suspend execution of the calling thread for at least n microseconds. *Why* and what is this analogous to? Can I call usleep to keep my philosophers sleeping?
They have their mutex on 2 forks for time_to_eat, they release the mutex and then usleep for time_sleeping?
Then if we have a philo awake, they are looking to take a fork so they can eat (no limit on their gluttony).
This is MT-Safe, meaning it can be  called in the presence of other threads.
*** Crude idea of tasks
- parse the arguments
- some kind of exit when a philosopher dies
- print some log statements - whenever a state changes? When there is a synchronisation (needed to avoid data races, apparently.)
- a framework whereby the philosophers change?
- a means for the philos to change their state -- how do you *record* the state that they are in?
  time that they have been in X state?
  time before they would die?
- track the time
  With no global variable allowed, we use gettimeofday
*** read up on pthreads
variables, structs. What do they hold?
Also refer back to this? https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
http://www.csc.villanova.edu/~mdamian/threads/posixthreads.html
** Mutex functions
https://www.geeksforgeeks.org/mutex-lock-for-linux-thread-synchronization/
As usual with that website, badly written but useful information.
First initialise, then lock:
#+begin_src c
int pthread_mutex_init(mutex, attributes);
int pthread_mutex_lock(*mutex);
#+end_src
So then I wonder what the / how the mutex protects a thing (an area of code?).
So for example, place it around the function that is called from pthread_create (currently launch_phil, but I suppose I will be changing that.)
The forks (between each philo) have to be protected by mutexes. **This implies that the thread called will be something like "philosopher takes a fork".**
** What is the diff between join and detach of threads
And how would I make them work?
detached threads finish and release their resources without having to join.
...so??
All the threads have to be either joined or detached. Detaching an already-detached thread means trouble (undefined behaviour).
"join is the equivalent of wait for processes" - so I could have a join on a locked fork request...?
" Joinable threads must be reaped or killed by other threads (using pthread_join) in order to free memory resources. Detached threads cannot be reaped or killed by other threads, and resources are automatically reaped on termination"
* modelling the task
** philosopher = thread
They eat, or sleep, or think - do I need to store that state?
** fork = mutex
In the simple sense, an array of mutexes; but how to number them?
If between the philosophers, the philos want their number fork *and* +1 (max number philo takes 0 instead of that).
I have given each philosopher a (space to hold a) mutex on each side. To "pick up" a fork they must...
#+begin_src c
if ((pthread_mutex_lock(p.l_fork) == 0) && (pthread_mutex_lock(p.r_fork) == 0))
		{
			report_state(p.seat, EAT);
			usleep(p.data->eat_time * 1000);	// HACK this is wrong because we arent storing microseconds (yet)
			p.eaten++;	// NOTE Does this record need to be locked while updating?
			pthread_mutex_unlock(p.l_fork);
			pthread_mutex_unlock(p.r_fork);
			report_state(p.seat, NAP);
			usleep(p.data->nap_time * 1000);	// HACK Wrong, should be in microseconds
		}
		else
		{
			pthread_mutex_unlock(p.l_fork);
			// FIXME Unitialised value and an invalid read in line below.
			pthread_mutex_unlock(p.r_fork);
			report_state(p.seat, 4);
        }
#+end_src
** Setting up variables.
number of forks = number of philosophers.
Number of philosophers = number of threads to create
Both of these would be arrays of ahead-unknown size: i.e. pointers
Meals -- when a philo reaches this number, they no longer try to eat(?) or they don't have(?) or carry on. When *all* philos reach that, we end the sim.
2nd arg of pthread_create is attributes - could use this to store philosopher number (or a general state-of-philosopher struct). NO, attributes are things like does it start detached.
** Protecting things other than the "forks", i.e logging
Without a mutex protecting the "report_state" function, I sometimes get interleaved messages. This implies storing that (or a link to it) in each thread/philosopher. So create philo->report mutex OR because this is *shared* between all philosophers (only one can report at once), is this for the t_table?
** allocation and initialisation
Doing my head in.
Any struct or typedef needs allocated, is that true?
Initialization is needed for the values of the philosophers, I guess. Where they are sat. Not their thread ID, because that is a pointer which gets filled in on pthread_create invocation. Right?
*** TODO Summarise what I actually *learned* about what to init
** When do the threads join / synchronise?
Can we have the join within the thread function? Must be possible.
Does the philosopher either side (i.e. waiting for a fork) have to join with them? Or does that make for explosions / clashes.
** What goes in our thread function, and where?
Imagine from the POV of the philo.
First off, tries to eat (possible to have a range of different starting strategies)
Takes two forks. Eat for X, releases forks, sleeps for Y.
? - Do we take the eating time as sleep as well? There's no reason it should  keep taking up processor time (unless to log something?)
If can't take two forks, release the other? Or wait and try again?
** TODO Sort out times
record the start time in t_table
What to do with the timestamps required by the report function. - how do you do the sums?
Need to be careful with the int limits because it could easily overflow. What size do you need?
* Submission requirements
** [#A] Match all requirements in project sheet
** HOLD presubmission checklist
- [ ] remove spare (ft_)printfs
- [ ] norminette all my files
- [ ] compile from fresh checkout
- [ ] run from fresh checkout
- [ ] Files are to be in a dir philo/ or similar.
