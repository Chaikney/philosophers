#+title:     Philosophers
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* Early notes
** Task set up
Philosophers are threads?
Any number of philosophers in one (only) of 3 states.
Same number of forks (resource).
Philosophers need 2 forks to eat.
No communication between philosophers (threads?)
The time in the three states is taken as an argument.
Philosophers are numbered and also have a sitting position (not sure why that matters, maybe because the forks stay in the same place).
How would you model the forks? They don't do anything, really. They have a position and are either in use or not in use. If in use, do we record (there) with philosopher is using the fork? Just that it is in use (reserved, has a mutex on it?)
MutEx = Mutual Exclusion.
Have to keep logs: Timestamps, philosopher numbers and one of five actions.
Seems like if there is only one philosopher there is only one fork, and she will die.
The location of the forks, does that matter or am I taking the metaphor too far? The forks don't *move*, so for example, 2 philos could eat alternately. Eat, release your forks. The other picks up and eats
There must be some key time after you have picked up a fork: time eating + plus time sleeping + time to die amounts to the time that can be spent thinking before it wants to eat (?). -- what are the warning states or times here?
*** Functions in play
*No* libft.
Lots of pthread things
"protect the forks with a mutex"??
Time-related functions (gettimeofday)
**** gettimeofday
#+begin_src c
#include <sys/time.h>
struct timeval {
	time_t 		tv_sec;
	suseconds_t	tv_usec
};
    int gettimeofday(struct timeval *tv, struct timezone *tz)
#+end_src
the timeval struct gives the number of seconds and microseconds since the Epoch (i.e. it just keeps going up after the start)
The timezone "is obsolete" and should normally be specified as NULL
To get milliseconds from  the timeval, I need a function. What should it return? (seconds * 1000) + (suseconds / 1000) ?
**** usleep
#+begin_src c
#include <unistd.h>
int usleep(useconds_t n);
#+end_src
Suspend execution of the calling thread for at least n microseconds. *Why* and what is this analogous to? Can I call usleep to keep my philosophers sleeping?
They have their mutex on 2 forks for time_to_eat, they release the mutex and then usleep for time_sleeping?
Then if we have a philo awake, they are looking to take a fork so they can eat (no limit on their gluttony).
This is MT-Safe, meaning it can be  called in the presence of other threads.
*** Crude idea of tasks
- parse the arguments
- some kind of exit when a philosopher dies
- print some log statements - whenever a state changes? When there is a synchronisation (needed to avoid data races, apparently.)
- a framework whereby the philosophers change?
- a means for the philos to change their state -- how do you *record* the state that they are in?
  time that they have been in X state?
  time before they would die?
- track the time
  With no global variable allowed, we use gettimeofday
*** read up on pthreads
variables, structs. What do they hold?
Also refer back to this? https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
http://www.csc.villanova.edu/~mdamian/threads/posixthreads.html
** Mutex functions
https://www.geeksforgeeks.org/mutex-lock-for-linux-thread-synchronization/
As usual with that website, badly written but useful information.
First initialise, then lock:
#+begin_src c
int pthread_mutex_init(mutex, attributes);
int pthread_mutex_lock(*mutex);
#+end_src
So then I wonder what the / how the mutex protects a thing (an area of code?).
So for example, place it around the function that is called from pthread_create (currently launch_phil, but I suppose I will be changing that.)
The forks (between each philo) have to be protected by mutexes. **This implies that the thread called will be something like "philosopher takes a fork".**
** What is the diff between join and detach of threads
And how would I make them work?
detached threads finish and release their resources without having to join.
...so??
All the threads have to be either joined or detached. Detaching an already-detached thread means trouble (undefined behaviour).
"join is the equivalent of wait for processes" - so I could have a join on a locked fork request...?
" Joinable threads must be reaped or killed by other threads (using pthread_join) in order to free memory resources. Detached threads cannot be reaped or killed by other threads, and resources are automatically reaped on termination"
* modelling the task
** philosopher = thread
They eat, or sleep, or think - do I need to store that state?
** fork = mutex
In the simple sense, an array of mutexes; but how to number them?
If between the philosophers, the philos want their number fork *and* +1 (max number philo takes 0 instead of that).
** Setting up variables.
number of forks = number of philosophers.
Number of philosophers = number of threads to create
Both of these would be arrays of ahead-unknown size: i.e. pointers
Meals -- when a philo reaches this number, they no longer try to eat(?) or they don't have(?) or carry on. When *all* philos reach that, we end the sim.
2nd arg of pthread_create is attributes - could use this to store philosopher number (or a general state-of-philosopher struct). NO, attributes are things like does it start detached.
** allocation and initialisation
Doing my head in.
Any struct or typedef needs allocated, is that true?
Initialization is needed for the values of the philosophers, I guess. Where they are sat. Not their thread ID, because that is a pointer which gets filled in on pthread_create invocation. Right?
** When do the threads join / synchronise?
Can we have the join within the thread function? Must be possible.
** What goes in our function, and where?
Imagine from the POV of the philo.
First off, tries to eat (possible to have a range of different starting strategies)
Takes two forks. Eat for X, releases forks, sleeps for Y.
If can't take two forks, release the other? Or wait and try again?
* Submission requirements
** [#A] Match all requirements in project sheet
** HOLD presubmission checklist
- [ ] remove stdio.h from my files
- [ ] remove spare (ft_)printfs
- [ ] norminette all my files (inc libft)
- [ ] compile from fresh checkout
- [ ] run from fresh checkout
- [ ] Files are to be in a dir philo/ or similar.
